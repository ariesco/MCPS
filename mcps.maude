load full-maude.maude
load aux.maude

fmod MCPS-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @MCPSCommand@ .

  subsort @MCPSCommand@ < @Input@ .

  *********************************************************************************
  *** Introduces the memory sorts into the corresponding loop attribute         ***
  *** Usage: (memory sorts SORT_1 ... SORT_n .)                                 ***
  *********************************************************************************
  op memory`sorts_. : @NeTokenList@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Introduces the unit sort into the corresponding loop attribute            ***
  *** Usage: (unit SORT .)                                                      ***
  *********************************************************************************
  op unit_. : @Token@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Introduces the unit sort and the id into the corresponding loop attribute ***
  *** The id is a natural number identifying the argument standing for the      ***
  *** identifier of the unit                                                    ***
  *** Usage: (unit SORT id NAT .)                                               ***
  *********************************************************************************
  op unit_id_. : @Token@ @Token@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Generates the JSON containing the transformed counterexample              ***
  *** Usage: (shared memory analysis modelCheck(INIT, FORMULA) .)               ***
  *********************************************************************************
  op shared`memory`analysis_. : @Bubble@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Generates the JSON containing the transformed counterexample              ***
  *** Usage: (msg passing analysis modelCheck(INIT, FORMULA) .)                 ***
  *********************************************************************************
  op msg`passing`analysis_. : @Bubble@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Introduces the operators in charge of creating messages.                  ***
  *** Usage: (msg creation OP_1 ... OP_n .)                                     ***
  *********************************************************************************
  op msg`creation_. : @NeTokenList@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Introduces the operators in charge of consuming messages.                 ***
  *** Usage: (msg consumption OP_1 ... OP_n .)                                  ***
  *********************************************************************************
  op msg`consumption_. : @NeTokenList@ -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Sets "process" as the current mode.                                       ***
  *** Usage: (set mode process .)                                               ***
  *********************************************************************************
  op set`mode`process`. : -> @MCPSCommand@ [ctor] .

  *********************************************************************************
  *** Sets "trace" as the current mode.                                         ***
  *** Usage: (set mode trace .)                                               ***
  *********************************************************************************
  op set`mode`trace`. : -> @MCPSCommand@ [ctor] .
endfm


fmod META-MCPS-SIGN is
 inc META-FULL-MAUDE-SIGN .

 op MCPS-GRAMMAR : -> FModule [memo] .
 eq MCPS-GRAMMAR = addImports((including 'MCPS-SIGNATURE .), GRAMMAR) .
endfm

fmod MCPS-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr EXT-BOOL .
 pr PRINT .
 pr MODE .

 sort AnalysisResult .
 *** The first argument indicates whether the analysis succeedeed.
 *** The second one contains either a JSON or an error message.
 op [_,_] : Bool QidList -> AnalysisResult [ctor] .

 *** Sorts used to store the information for the "process" mode for message passing languages
 sort ProcessInfo CompInfo .
 subsort ProcessInfo < CompInfo .
 *** Id
 *** Final value
 *** Msgs sent
 *** Msgs received
 op [_,_,_,_] : Term Term TermList TermList -> ProcessInfo [ctor] .
 op noInfo : -> CompInfo [ctor] .
 op __ : CompInfo CompInfo -> CompInfo [ctor assoc comm id: noInfo] .

 vars QIL QIL' MBQIL MAQIL PQIL UQIL : QidList .
 vars T T' T'' T1 T2 T3 T4 P LHS RHS : Term .
 vars TL TL' TL'' TL1 TL2 PROPS : TermList .
 vars QS QS' MS RL RC RD : QidSet .
 vars CI CI' CI'' CIA : CompInfo .
 var  ME : ModuleExpression .
 var  TIL : TraceInfoList .
 var  R4T : Result4Tuple .
 var  SB : Substitution .
 vars TS TS' : TermSet .
 var  COND : Condition .
 var  PI : ProcessInfo .
 var  RP : ResultPair .
 var  CTXT : Context .
 var  TI : TraceInfo .
 var  DB : Database .
 vars Q US Q' : Qid .
 var  AtS : AttrSet .
 var  C : Constant .
 var  V : Variable .
 var  RS : RuleSet .
 var  MODE : Mode .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  S : Sort .

 **********************************************************************************
 ***                                                                            ***
 ***                           MAIN FUNCTION: processSMA                        ***
 ***                                                                            ***
 ***                Processes the shared memory analysis command                ***
 ***                                                                            ***
 **********************************************************************************
 op processSMA : Term ModuleExpression QidSet Qid Nat Database -> AnalysisResult .
 ceq processSMA(T, ME, QS, Q, N, DB) = processSMA(T, M, QS, Q, N)
  if M := if compiledModule(ME, DB)
          then getFlatModule(ME, DB)
          else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
          fi .

 op processSMA : Term Module QidSet Qid Nat -> AnalysisResult .
 ceq processSMA(T, M, QS, Q, N) = processSMAParse(T', M, QS, Q, N, PROPS)
  if RP := metaParse(M, downQidList(T), 'ModelCheckResult) /\
     T' := getTerm(RP) /\
     PROPS := getProps(M, T') .
 eq processSMA(T, M, QS, Q, N) = [false, error-term-mc] [owise] .

 op processSMAParse : Term Module QidSet Qid Nat TermList -> AnalysisResult .
 ceq processSMAParse(T, M, QS, Q, N, PROPS) = if T' == 'true.Bool
                                             then [false, error-no-counter]
                                             else processSMARules(M, T', QS, Q, N, PROPS)
                                             fi
  if T' := getTerm(metaReduce(M, T)) .

 op processSMARules : Module Term QidSet Qid Nat TermList -> AnalysisResult .
 ceq processSMARules(M, T, QS, Q, N, PROPS) = [true, QIL]
  if QS' := getMemoryRules(M, QS) /\
     QIL := '`{ 'steps '= ' '`[ processCounterexample(M, T, QS', QS, Q, N, PROPS) '`] '`} .
 eq processSMARules(M, T, QS, Q, N, PROPS) = [false, error-no-terms] [owise] .

 op processCounterexample : Module Term QidSet QidSet Qid Nat TermList -> QidList .
 ceq processCounterexample(M, 'counterexample[TL], RL, MS, US, N, PROPS) =
                              $processCounterexample(M, TL'', RL, MS, US, N, PROPS)
  if '__[TL'] := putTogether(TL) /\
     TL'' := closeCounterexample(M, TL', RL) /\
     N' := | TL'' | .

 op $processCounterexample : Module TermList QidSet QidSet Qid Nat TermList -> QidList .
 eq $processCounterexample(M, empty, RL, MS, US, N, PROPS) = nil .
 ceq $processCounterexample(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), RL, MS,
                            US, N, PROPS) =
                    jsonStep(M, T1, T3, MS, US, N, Q, PROPS)
                    if TL == empty
                    then nil
                    else '`,
                         $processCounterexample(M, ('`{_`,_`}[T3, T4], TL), RL, MS, US,
                                                N, PROPS)
                    fi
  if Q := downTerm(T2) /\
     Q in RL .
 eq $processCounterexample(M, (T, TL), RL, MS, US, N, PROPS) =
                         $processCounterexample(M, TL, RL, MS, US, N, PROPS) [owise] .

 op jsonStep : Module Term Term QidSet Sort Nat Qid TermList -> QidList .
 ceq jsonStep(M, T, T', MS, S, N, Q, PROPS) =
               '`{ '\n
               UQIL
               '\t 'memory-before  '= ' '`{     MBQIL     '`} '`, '\n
               '\t 'memory-after ' '= ' '`{     MAQIL     '`} '`, '\n
               '\t 'props        ' '= ' '`[ '\n PQIL  '\n '`]     '\n
               '`} '\n
  if TS    := getTermsOfSortQS(M, T, MS) /\
     TS'   := getTermsOfSortQS(M, T', MS) /\
     MBQIL := printMemory(M, TS) /\
     MAQIL := printMemory(M, TS') /\
     PQIL  := printProps(M, T, T', PROPS) /\
     UQIL  := printUnit(M, T, T', S, N, Q) .

 op printUnit : Module Term Term Sort Nat Qid -> QidList .
 ceq printUnit(M, T1, T2, S, N, Q) = QIL QIL'
  if {T, Ty, SB, CTXT} := findXapply(M, T1, Q, 0, T2) /\
     LHS := getLHS(M, Q) /\
     T' := applySb(getTermsOfSort(M, LHS, S), SB) /\
     QIL := if N =/= 0
            then '\t 'id '= ' metaPrettyPrint(M, getNth(T', N)) '`, '\n
            else nil
            fi /\
     QIL' := '\t 'unit '= metaPrettyPrint(M, T') '`, '\n .

 **********************************************************************************
 ***                                                                            ***
 ***                           MAIN FUNCTION: processMPA                        ***
 ***                                                                            ***
 ***               Processes the message passing analysis command               ***
 ***                                                                            ***
 **********************************************************************************

 *** Term    Default module   Msg creation   Msg consumption   Unit   Id   Mode   Database
 op processMPA : Term ModuleExpression QidSet QidSet Qid Nat Mode Database
                 -> AnalysisResult .
 ceq processMPA(T, ME, QS, QS', Q, N, MODE, DB) = processMPA(T, M, QS, QS', Q, N, MODE)
  if M := if compiledModule(ME, DB)
          then getFlatModule(ME, DB)
          else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
          fi .

 op processMPA : Term Module QidSet QidSet Qid Nat Mode -> AnalysisResult .
 ceq processMPA(T, M, QS, QS', Q, N, MODE) =
                                      processMPAParse(T', M, QS, QS', Q, N, MODE, PROPS)
  if RP := metaParse(M, downQidList(T), 'ModelCheckResult) /\
     T' := getTerm(RP) /\
     PROPS := getProps(M, T') .
 eq processMPA(T, M, QS, QS', Q, N, MODE) = [false, error-term-mc] [owise] .

 op processMPAParse : Term Module QidSet QidSet Qid Nat Mode TermList -> AnalysisResult .
 ceq processMPAParse(T, M, QS, QS', Q, N, MODE, PROPS) =
                                 if T' == 'true.Bool
                                 then [false, error-no-counter]
                                 else processMPARules(M, T', QS, QS', Q, N, MODE, PROPS)
                                 fi
  if T' := getTerm(metaReduce(M, T)) .

 op processMPARules : Module Term QidSet QidSet Qid Nat Mode TermList -> AnalysisResult .
 ceq processMPARules(M, 'counterexample[TL], QS, QS', Q, N, MODE, PROPS) =
                               processMPAMode(M, TL'', QS, QS', Q, N, MODE, PROPS, RC, RD)
  if RC := getRulesUsing(M, QS) /\
     RD := getRulesUsing(M, QS') /\
     '__[TL'] := putTogether(TL) /\
     TL'' := closeCounterexample(M, TL', RC ; RD) .

 op processMPAMode : Module TermList QidSet QidSet Qid Nat Mode TermList QidSet QidSet ->
                     AnalysisResult .
 ceq processMPAMode(M, TL, QS, QS', Q, N, process, PROPS, RC, RD) = [true, QIL]
  if QIL := processCounterProc(M, TL, QS, QS', Q, N, RC, RD, noInfo) .
 *** We need to start with a dummy TraceInfo, so the set is built on top of noInfo.
 *** This dummy element is removed in the base case of processCounterTrace
 ceq processMPAMode(M, TL, QS, QS', Q, N, trace, PROPS, RC, RD) = [true, QIL]
  if QIL := processCounterTrace(M, TL, QS, QS', Q, N, PROPS, RC, RD,
                                | ''foo.Qid, 'foo, empty, noInfo, noInfo, nil |) .

 op processCounterTrace : Module TermList QidSet QidSet Qid Nat TermList QidSet QidSet
                          TraceInfoList -> QidList .
 *** The dummy element in the head is removed.
 ceq processCounterTrace(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), QS, QS', Q, N,
                         PROPS, RC, RD, TIL) =
        processCounterTrace(M, ('`{_`,_`}[T3, T4], TL), QS, QS', Q, N, PROPS, RC, RD, TIL)
  if Q' := downTerm(T2) /\
     not (Q' in (RC ; RD)) /\
     CI := getLastCI(TIL) /\
     CI' := updateValues(M, T1, CI, Q, N) /\
     CIA := updateValues(M, T3, CI', Q, N) /\
     QIL := printProps(M, T1, T3, PROPS) /\
     TI := [ 'prop-changed, CI', CIA, QIL ] .
 ceq processCounterTrace(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), QS, QS', Q, N,
                         PROPS, RC, RD, TIL) =
        processCounterTrace(M, ('`{_`,_`}[T3, T4], TL), QS, QS', Q, N, PROPS, RC, RD, TIL TI)
  if Q' := downTerm(T2) /\
     Q' in RC /\
     CI := getLastCI(TIL) /\
     [T, T', TL', empty] := getProcInfoSend(M, T1, T3, Q', QS, Q, N) /\
     CI' := updateValues(M, T1, CI, Q, N) /\
     *** CIA := combine(updateValues(M, T3, CI', Q, N), [T, T', TL', empty]) /\
     CIA := updateValues(M, T3, combine(CI', [T, T', TL', empty]), Q, N) /\
     QIL := printProps(M, T1, T3, PROPS) /\
     TI := | T, 'msg-sent, TL', CI', CIA, QIL | .
 ceq processCounterTrace(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), QS, QS', Q, N,
                         PROPS, RC, RD, TIL) =
        processCounterTrace(M, ('`{_`,_`}[T3, T4], TL), QS, QS', Q, N, PROPS, RC, RD, TIL TI)
  if Q' := downTerm(T2) /\
     Q' in RD /\
     CI := getLastCI(TIL) /\
     [T, T', empty, TL'] := getProcInfoReceive(M, T1, T3, Q', QS', Q, N) /\
     CI' := updateValues(M, T1, CI, Q, N) /\
     *** CIA := combine(updateValues(M, T3, CI', Q, N), [T, T', empty, TL']) /\
     CIA := updateValues(M, T3, combine(CI', [T, T', empty, TL']), Q, N) /\

     QIL := printProps(M, T1, T3, PROPS) /\
     TI := | T, 'msg-consumed, TL', CI', CIA, QIL | .
 eq processCounterTrace(M, TL, QS, QS', Q, N, PROPS, RC, RD, TI TIL) =
                                   printTraceInfoList(M, TIL) [owise] .

 sort TraceInfo TraceInfoList .
 subsort TraceInfo < TraceInfoList .
 *** Id
 *** Action (either 'msg-created or 'msg-consumed)
 *** Msgs
 *** Current state
 *** Next state
 *** Props info
 op |_,_,_,_,_,_| : Term Qid TermList CompInfo CompInfo QidList -> TraceInfo .
 *** Action ('prop-changed for the time being)
 *** Current state
 *** Next state
 *** Props info
 op [_,_,_,_] : Qid CompInfo CompInfo QidList -> TraceInfo .
 op mtTrace : -> TraceInfoList [ctor] .
 op __ : TraceInfoList TraceInfoList -> TraceInfoList [ctor assoc id: mtTrace] .

 **********************************************************************************
 *** Auxiliary function: printTraceInfoList                                     ***
 *** Prints the trace as a JSON.                                                ***
 **********************************************************************************

 op printTraceInfoList : Module TraceInfoList -> QidList .
 eq printTraceInfoList(M, TIL) = '`{ 'steps '= '`[ '\n $printTraceInfoList(M, TIL)
                                 '`] '`} .

 op $printTraceInfoList : Module TraceInfoList -> QidList .
 eq $printTraceInfoList(M, mtTrace) = nil .
 eq $printTraceInfoList(M, TI TIL) = printTraceInfo(M, TI) '\n
                                     $printTraceInfoList(M, TIL) .

 op printTraceInfo : Module TraceInfo -> QidList .
 eq printTraceInfo(M, | T, Q, TL, CI, CIA, QIL |) =
        '`{ '\n
        'id      '= metaPrettyPrint(M, T) '`, '\n
        'action  '= Q '`, '\n
        'messages '= '`[ printList(M, TL) '`] '`, '\n
        printCompInfoTrace(M, CI, 'processes-before) '`, '\n
        printCompInfoTrace(M, CIA, 'processes-after) '`, '\n
        'props '= QIL '\n
        '`} .

 **********************************************************************************
 *** Auxiliary function: getLastCI                                              ***
 *** Returns the CompInfo in the last element of the list.                      ***
 **********************************************************************************

 op getLastCI : TraceInfoList ~> CompInfo .
 eq getLastCI(TIL | T, Q, TL, CI, CIA, QIL |) = CIA .

 **********************************************************************************
 *** Auxiliary function: processCounterProc                                     ***
 *** Computes the JSON for message-passing semantics with "process" mode.       ***
 **********************************************************************************

 op processCounterProc : Module TermList QidSet QidSet Qid Nat QidSet QidSet CompInfo ->
                         QidList .
 eq processCounterProc(M, empty, QS, QS', Q, N, RC, RD, CI) = printCompInfo(M, CI) .
 ceq processCounterProc(M, ('`{_`,_`}[T1, T2], TL), QS, QS', Q, N, RC, RD, CI) =
                                   processCounterProc(M, TL, QS, QS', Q, N, RC, RD, CI')
  if Q' := downTerm(T2) /\
     not (Q' in (RC ; RD)) /\
     CI' := updateValues(M, T1, CI, Q, N) .
 ceq processCounterProc(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), QS, QS', Q, N, RC, RD, CI) =
                 processCounterProc(M, ('`{_`,_`}[T3, T4], TL), QS, QS', Q, N, RC, RD, CI'')
  if Q' := downTerm(T2) /\
     Q' in RC /\
     PI := getProcInfoSend(M, T1, T3, Q', QS, Q, N) /\
     CI' := combine(CI, PI) /\
     CI'' := updateValues(M, T1, CI', Q, N) .
 ceq processCounterProc(M, ('`{_`,_`}[T1, T2], '`{_`,_`}[T3, T4], TL), QS, QS', Q, N, RC, RD, CI) =
                 processCounterProc(M, ('`{_`,_`}[T3, T4], TL), QS, QS', Q, N, RC, RD, CI'')
  if Q' := downTerm(T2) /\
     Q' in RD /\
     PI := getProcInfoReceive(M, T1, T3, Q', QS', Q, N) /\
     CI' := combine(CI, PI) /\
     CI'' := updateValues(M, T1, CI', Q, N) .

 **********************************************************************************
 *** Auxiliary function: updateValues                                           ***
 *** Updates the values of all units.                                           ***
 **********************************************************************************

 op updateValues : Module Term CompInfo Sort Nat -> CompInfo .
 ceq updateValues(M, T, CI, S, N) = updateValues(M, TS, N, CI)
  if TS := getTermsOfSort(M, T, S) .

 op updateValues : Module TermSet Nat CompInfo -> CompInfo .
 eq updateValues(M, emptyTermSet, N, CI) = CI .
 ceq updateValues(M, T | TS, N, CI) = updateValues(M, TS, N, CI')
  if PI := [getNth(T, N), T, empty, empty] /\
     CI' := combine(CI, PI) .

 **********************************************************************************
 *** Auxiliary function: getSubstitutionOp                                      ***
 *** Looks for the term that substituted the consumption operator.              ***
 **********************************************************************************

 op getSubstitutionOp : Term Term QidSet ~> Term .
 eq getSubstitutionOp(Q[TL], T, Q ; QS) = T .
 ceq getSubstitutionOp(C, T, QS) = T
  if getName(C) in QS .
 eq getSubstitutionOp(Q[TL], Q[TL'], QS) = getSubstitutionOp*(TL, TL', QS) [owise] .

 op getSubstitutionOp* : TermList TermList QidSet ~> Term .
 ceq getSubstitutionOp*((T, TL), (T', TL'), QS) = T''
  if T'' := getSubstitutionOp(T, T', QS) .
 eq getSubstitutionOp*((T, TL), (T', TL'), QS) = getSubstitutionOp*(TL, TL', QS) [owise] .

 **********************************************************************************
 *** Auxiliary function: findXapply                                             ***
 *** Applies metaXapply until the appropriate matching is found.                ***
 **********************************************************************************

 op findXapply : Module Term Qid Nat Term -> Result4Tuple .
 ceq findXapply(M, T1, Q, N, T2) = R4T
  if R4T := metaXapply(M, T1, Q, none, 0, unbounded, N) /\
     T2 == getTerm(R4T) .
 eq findXapply(M, T1, Q, N, T2) = findXapply(M, T1, Q, s(N), T2) [owise] .

 **********************************************************************************
 *** Auxiliary function: termContaining                                         ***
 *** Returns the first term containing any term with a top operator contained   ***
 *** in QS.                                                                     ***
 **********************************************************************************

 op termContaining : Module TermList QidSet ~> Term .
 ceq termContaining(M, (T, TL), QS) = if TL' == empty
                                      then termContaining(M, TL, QS)
                                      else T
                                      fi
  if TL' := getTermsTopOps(T, QS) .

 **********************************************************************************
 *** Auxiliary function: getProcInfoSend                                        ***
 *** Computes the changes produced when sending a message.                      ***
 *** It is computed for the "process" mode.                                     ***
 *** 1st argument: Module were the rewrites take place.                         ***
 *** 2nd argument: Term being rewritten.                                        ***
 *** 3rd argument: Reached term (next term in the counterexample).              ***
 *** 4th argument: Rule label used in the counterexample.                       ***
 *** 5th argument: Set of operators producing messages.                         ***
 *** 6th argument: Unit sort.                                                   ***
 *** 7th argument: Id argument.                                                 ***
 **********************************************************************************

 op getProcInfoSend : Module Term Term Qid QidSet Qid Nat -> ProcessInfo .
 ceq getProcInfoSend(M, T1, T2, Q, QS, S, N) = [T'', T3, TL', empty]
  if {T, Ty, SB, CTXT} := findXapply(M, T1, Q, 0, T2) /\
     LHS := getLHS(M, Q) /\
     TS := getTermsOfSort(M, LHS, S) /\
     TL := set2list(TS) /\
     T' := termContaining(M, TL, QS) /\
     T'' := applySb(getNth(T', N), SB) /\
     TL' := applySb(getTermsTopOps(T', QS), SB) /\
     T3 := applySb(T', SB) .

 **********************************************************************************
 *** Auxiliary function: getProcInfoReceive                                     ***
 *** Computes the changes produced when consuming a message.                    ***
 *** It is computed for the "process" mode.                                     ***
 *** 1st argument: Module were the rewrites take place.                         ***
 *** 2nd argument: Term being rewritten.                                        ***
 *** 3rd argument: Reached term (next term in the counterexample).              ***
 *** 4th argument: Rule label used in the counterexample.                       ***
 *** 5th argument: Set of operators consuming messages.                         ***
 *** 6th argument: Unit sort.                                                   ***
 *** 7th argument: Id argument.                                                 ***
 **********************************************************************************

 op getProcInfoReceive : Module Term Term Qid QidSet Qid Nat -> ProcessInfo .
 ceq getProcInfoReceive(M, T1, T2, Q, QS, S, N) = [T'', T', empty, T4]
  if {T, Ty, SB, CTXT} := findXapply(M, T1, Q, 0, T2) /\
     LHS := getLHS(M, Q) /\
     RHS := getRHS(M, Q) /\
     TS := getTermsOfSort(M, LHS, S) /\
     TL := applySb*(set2list(TS), SB) /\
     T' := termContaining(M, TL, QS) /\
     T'' := getNth(T', N) /\
     T3 := getSubstitutionOp(LHS, RHS, QS) /\
     T4 := applySb(T3, SB) .

 **********************************************************************************
 *** Auxiliary function: combine                                                ***
 *** Combines a ProcessInfo into a CompInfo. If the id exists it add the        ***
 *** elements, otherwise, it adds the ProcessInfo                               ***
 **********************************************************************************

 op combine : CompInfo ProcessInfo -> CompInfo .
 eq combine(CI [T, T', TL, TL'], [T, T1, TL1, TL2]) = CI [T, T1, (TL, TL1), (TL', TL2)] .
 eq combine(CI, PI) = CI PI [owise] .

 **********************************************************************************
 *** Auxiliary function: printCompInfo                                          ***
 *** Uses metaPrettyPrint to generate a list of Qids separated by commas.       ***
 **********************************************************************************

 op printCompInfo : Module CompInfo -> QidList .
 eq printCompInfo(M, CI) = '`{ 'processes '= '`[ $printCompInfo(M, CI) '\n '`] '`} .

 op printCompInfoTrace : Module CompInfo Qid -> QidList .
 eq printCompInfoTrace(M, CI, Q) = Q '= '`[ $printCompInfo(M, CI) '\n '`] .

 op $printCompInfo : Module CompInfo -> QidList .
 eq $printCompInfo(M, noInfo) = nil .
 eq $printCompInfo(M, PI CI) = printProcessInfo(M, PI)
                               if CI == noInfo
                               then nil
                               else '`, $printCompInfo(M, CI)
                               fi .

 op printProcessInfo : Module ProcessInfo -> QidList .
 eq printProcessInfo(M, [T, T', TL, TL']) =
      '\n '`{ '\n
      '\t 'id          '= metaPrettyPrint(M, T)    '`, '\n
      '\t 'value       '= metaPrettyPrint(M, T')   '`, '\n
      '\t 'sent        '= '`[ printList(M, TL) '`] '`, '\n
      '\t 'consumed    '= '`[ printList(M, TL') '`] '\n
      '`} .

 **********************************************************************************
 *** Auxiliary function: printList                                              ***
 *** Uses metaPrettyPrint to generate a list of Qids separated by commas.       ***
 **********************************************************************************
 op printList : Module TermList -> QidList .
 eq printList(M, empty) = nil .
 eq printList(M, (T, TL)) = metaPrettyPrint(M, T)
                            if TL == empty
                            then nil
                            else '`, ' printList(M, TL)
                            fi .

 **********************************************************************************
 *** Auxiliary function: getRulesUsing                                          ***
 *** Returns the set of rule labels in charge of sending messages.              ***
 **********************************************************************************
 op getRulesUsing : Module QidSet -> QidSet .
 eq getRulesUsing(M, QS) = getRulesUsing(getRls(M), QS) .

 op getRulesUsing : RuleSet QidSet -> QidSet .
 ceq getRulesUsing(rl T => T' [label(Q) AtS] . RS, QS) = Q ; getRulesUsing(RS, QS)
  if N := | getTermsTopOps(T, QS) | /\
     N' := | getTermsTopOps(T', QS) | /\
     N > N' .
 eq getRulesUsing(RS, QS) = none [owise] .

 **********************************************************************************
 *** Auxiliary function: |_|                                                    ***
 *** Computes the size of the list.                                             ***
 **********************************************************************************

 op |_| : TermList -> Nat .
 eq | (empty).TermList | = 0 .
 eq | (T, TL) | = s(| TL |) .

 **********************************************************************************
 *** Auxiliary function: getTermsTopOp                                          ***
 *** Returns all the terms with this Qid as top operator.                       ***
 **********************************************************************************

 op getTermsTopOps : Term QidSet -> TermList .
 eq getTermsTopOps(T, none) = empty .
 eq getTermsTopOps(T, Q ; QS) = getTermsTopOp(T, Q), getTermsTopOps(T, QS) .

 op getTermsTopOp : Term Qid -> TermList .
 eq getTermsTopOp(V, Q) = empty .
 eq getTermsTopOp(C, Q) = if getName(C) == Q
                          then C
                          else empty
                          fi .
 eq getTermsTopOp(Q[TL], Q') = if Q == Q'
                               then Q[TL]
                               else getTermsTopOp*(TL, Q')
                               fi .

 op getTermsTopOp* : TermList Qid -> TermList .
 eq getTermsTopOp*(empty, Q) = empty .
 eq getTermsTopOp*((T, TL), Q) = getTermsTopOp(T, Q), getTermsTopOp*(TL, Q) .

 **********************************************************************************
 *** Auxiliary function: applySb                                                ***
 *** Applies a substitution to the given term.                                  ***
 **********************************************************************************

 op applySb : Term Substitution -> Term .
 eq applySb(V, (V <- T ; SB)) = T .
 eq applySb(Q[TL], SB) = Q[applySb*(TL, SB)] .
 eq applySb(T, SB) = T [owise] .

 op applySb* : TermList Substitution -> TermList .
 eq applySb*(empty, SB) = empty .
 eq applySb*((T, TL), SB) = applySb(T, SB), applySb*(TL, SB) .

 **********************************************************************************
 *** Auxiliary function: getLHS                                                 ***
 *** Returns the lefthand side of the rule identified by the given label.       ***
 **********************************************************************************
 op getLHS : Module Qid ~> Term .
 ceq getLHS(M, Q) = T
  if rl T => T' [AtS label(Q)] . RS := getRls(M) .
 ceq getLHS(M, Q) = T
  if crl T => T' if COND [AtS label(Q)] . RS := getRls(M) .

 **********************************************************************************
 *** Auxiliary function: getRHS                                                 ***
 *** Returns the rigthand side of the rule identified by the given label.       ***
 **********************************************************************************
 op getRHS : Module Qid ~> Term .
 ceq getRHS(M, Q) = T'
  if rl T => T' [AtS label(Q)] . RS := getRls(M) .
 ceq getRHS(M, Q) = T'
  if crl T => T' if COND [AtS label(Q)] . RS := getRls(M) .

 **********************************************************************************
 *** Auxiliary function: getNth                                                 ***
 *** Returns the nth argument of the term.                                      ***
 **********************************************************************************
 op getNth : Term Nat ~> Term .
 eq getNth(Q[TL], N) = getNth*(TL, N) .

 op getNth* : TermList Nat ~> Term .
 eq getNth*((T, TL), 1) = T .
 eq getNth*((T, TL), s(s(N))) = getNth*(TL, s(N)) .

 **********************************************************************************
 *** Auxiliary function: printProps                                             ***
 *** Depicts the name, arguments, and value (before and after) of all atomic    ***
 *** properties.                                                                ***
 **********************************************************************************
 op printProps : Module Term Term TermList -> QidList .
 eq printProps(M, T, T', empty) = nil .
 eq printProps(M, T, T', (P, PROPS)) =
             printProp(M, T, T', P)
             if PROPS == empty
             then nil
             else '`, '\n printProps(M, T, T', PROPS)
             fi .

 op printProp : Module Term Term Term -> QidList .
 ceq printProp(M, T, T', P) = '\t '\t '`{ printPropNameArgs(M, P)
                              '\t '\t 'prop '= QIL '-> QIL'
                              '`}
  if T1 := getTerm(metaReduce(M, '_|=_[T, P])) /\
     T2 := getTerm(metaReduce(M, '_|=_[T', P])) /\
     QIL := if T1 == 'true.Bool
            then 'true
            else 'false
            fi /\
     QIL' := if T2 == 'true.Bool
             then 'true
             else 'false
             fi .

 op printPropNameArgs : Module Term -> QidList .
 eq printPropNameArgs(M, C) = 'name '= getName(C) '`, '\n
                              '\t '\t 'args '= '`[ '`] '`, '\n .
 eq printPropNameArgs(M, Q[TL]) = 'name '= Q '`, '\n
                                  '\t '\t 'args '= '`[ printPropArgs(M, TL) '`] '`, '\n .

 op printPropArgs : Module TermList -> QidList .
 eq printPropArgs(M, empty) = nil .
 ceq printPropArgs(M, (T, TL)) = QIL
                                 if TL == empty
                                 then nil
                                 else '`, printPropArgs(M, TL)
                                 fi
  if QIL := metaPrettyPrint(M, T) .

 **********************************************************************************
 *** Auxiliary function: getProps                                               ***
 *** Extracts the atomic formulas from the LTL formula.                         ***
 **********************************************************************************

 op getProps : Module Term -> TermList .
 eq getProps(M, Q[T, T']) = $getProps(M, T') .

 op $getProps : Module Term -> TermList .
 ceq $getProps(M, T) = T
  if getType(metaReduce(M, T)) == 'Prop .
 ceq $getProps(M, Q[TL]) = $getProps*(M, TL)
  if getType(metaReduce(M, Q[TL])) =/= 'Prop .
 eq $getProps(M, T) = empty [owise] .

 op $getProps* : Module TermList -> TermList .
 eq $getProps*(M, empty) = empty .
 eq $getProps*(M, (T, TL)) = $getProps(M, T),
                             $getProps*(M, TL) .

 **********************************************************************************
 *** Auxiliary function: closeCounterexample                                    ***
 *** It adds the final state generating the loop if the last rule is one of     ***
 *** the rules of interest, so we can access the final state of the memory.     ***
 **********************************************************************************
 op closeCounterexample : Module TermList QidSet -> TermList .
 ceq closeCounterexample(M, (TL, '`{_`,_`}[T1, T2]), RL) =
                                $closeCounterexample(M, (TL, '`{_`,_`}[T1, T2]), T1, Q, 0)
  if Q := downTerm(T2) /\
     Q in RL .
 eq closeCounterexample(M, TL, RL) = TL [owise] .

 op $closeCounterexample : Module TermList Term Qid Nat -> TermList .
 ceq $closeCounterexample(M, TL, T, Q, N) = if closed(TL, T')
                                            then (TL, '`{_`,_`}[T', ''#$foo.Qid])
                                            else $closeCounterexample(M, TL, T, Q, s(N))
                                            fi
  if T' := getTerm(metaXapply(M, T, Q, none, 0, unbounded, N)) .
 eq $closeCounterexample(M, TL, T, Q, N) = TL [owise] .

 op closed : TermList Term -> Bool .
 eq closed(empty, T) = false .
 eq closed(('`{_`,_`}[T1, T2], TL), T) = T1 == T or-else closed(TL, T) .

 **********************************************************************************
 *** Auxiliary function: printMemory                                            ***
 *** Prints the terms in the termset.                                           ***
 **********************************************************************************

 op printMemory : Module TermSet -> QidList .
 eq printMemory(M, emptyTermSet) = nil .
 eq printMemory(M, T | TS) = metaPrettyPrint(M, T)
                             if TS == emptyTermSet
                             then nil
                             else '`, printMemory(M, TS)
                             fi .

 **********************************************************************************
 *** Auxiliary function: getMemoryRules                                         ***
 *** Given the current module and the set of sorts used for the memory          ***
 *** it returns the set of rule labels that modifies terms of these sorts.      ***
 **********************************************************************************
 op getMemoryRules : Module QidSet -> QidSet .
 eq getMemoryRules(M, QS) = getMemoryRules(M, getRls(M), QS) .

 op getMemoryRules : Module RuleSet QidSet -> QidSet .
 eq getMemoryRules(M, RS, Q ; QS) = getMemoryRules*(M, RS, Q) ;
                                    getMemoryRules(M, RS, QS) .
 eq getMemoryRules(M, RS, none) = none .

 op getMemoryRules* : Module RuleSet Sort -> QidSet .
 ceq getMemoryRules*(M, rl T => T' [label(Q) AtS] . RS, S) = Q
  if TS := getTermsOfSort(M, T, S) /\
     TS' := getTermsOfSort(M, T', S) /\
     (TS minus TS') =/= emptyTermSet .
 eq getMemoryRules*(M, RS, Q) = none [owise] .

 **********************************************************************************
 *** Auxiliary function: getTermsOfSortQS                                       ***
 *** Returns a set of terms of the given sorts found in the given term.         ***
 **********************************************************************************
 op getTermsOfSortQS : Module Term QidSet -> TermSet .
 eq getTermsOfSortQS(M, T, none) = emptyTermSet .
 eq getTermsOfSortQS(M, T, Q ; QS) = getTermsOfSort(M, T, Q) |
                                     getTermsOfSortQS(M, T, QS) .

 **********************************************************************************
 *** Auxiliary function: getTermsOfSort                                         ***
 *** Returns a set of terms of the given sort found in the given term.          ***
 **********************************************************************************
 op getTermsOfSort : Module Term Sort -> TermSet .
 ceq getTermsOfSort(M, T, S) = T
  if Ty := getType(metaReduce(M, T)) /\
     sameKind(M, Ty, S) /\
     sortLeq(M, Ty, S) .
 ceq getTermsOfSort(M, Q[TL], S) = getTermsOfSort*(M, TL, S)
  if Ty := getType(metaReduce(M, Q[TL])) /\
     (not sameKind(M, Ty, S)) or-else (not sortLeq(M, Ty, S)) .
 eq getTermsOfSort(M, T, S) = emptyTermSet [owise] .

 op getTermsOfSort* : Module TermList Sort -> TermSet .
 eq getTermsOfSort*(M, empty, S) = emptyTermSet .
 eq getTermsOfSort*(M, (T, TL), S) = getTermsOfSort(M, T, S) |
                                     getTermsOfSort*(M, TL, S) .

 **********************************************************************************
 *** Auxiliary function: putTogether                                            ***
 *** Given the current module and the set of sorts used for the memory          ***
 *** it returns the set of rule labels that modifies terms of these sorts.      ***
 **********************************************************************************
 op putTogether : TermList ~> Term .
 eq putTogether(T) = T .
 eq putTogether(('__[TL], '__[TL'], TL'')) = putTogether(('__[TL, TL'], TL'')) .
 eq putTogether(('__[TL], T)) = '__[TL, T] [owise] .

 **********************************************************************************
 *** Auxiliary function: _minus_                                                ***
 *** Removes the elements in the second set from the first one.                 ***
 **********************************************************************************
 op _minus_ : TermSet TermSet -> TermSet .
 eq (T | TS) minus (T | TS') = TS minus TS' .
 eq TS minus TS' = TS [owise] .

 **********************************************************************************
 *** Auxiliary function: _in_                                                   ***
 *** Checks whether the term is in the set.                                     ***
 **********************************************************************************
 op _in_ : Term TermSet -> Bool .
 eq T in (T | TS) = true .
 eq T in TS = false [owise] .

 **********************************************************************************
 *** Auxiliary function: _in_                                                   ***
 *** Checks whether the term is in the set.                                     ***
 **********************************************************************************
 op _in_ : Qid QidSet -> Bool .
 eq Q in (Q ; QS) = true .
 eq Q in QS = false [owise] .

 **********************************************************************************
 *** Auxiliary function: set2list                                               ***
 *** Transforms a set of terms into a list.                                     ***
 **********************************************************************************
 op set2list : TermSet -> TermList .
 eq set2list(emptyTermSet) = empty .
 eq set2list(T | TS) = T, set2list(TS) .
endfm

mod MCPS is
 pr MCPS-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 inc META-MCPS-SIGN .

 var  MCPSDC : MCPSDatabaseClass .
 var  ME : ModuleExpression .
 var  AtS : AttributeSet .
 vars QS QS' : QidSet .
 vars Q Q' Q'' : Qid .
 var  DB : Database .
 var  QIL : QidList .
 vars T T' : Term .
 var  S : String .
 vars N N' : Nat .
 var  M : Mode .
 var  B : Bool .
 var  O : Oid .

 sort MCPSDatabaseClass .
 subsort MCPSDatabaseClass < DatabaseClass .

 op MCPSDatabase : -> MCPSDatabaseClass [ctor] .


 *********************************************************************************
 *** New attributes for the loop                                               ***
 ***                                                                           ***
 *********************************************************************************
 op memory :_ : QidSet -> Attribute [ctor] .
 op unit :_ : Sort -> Attribute [ctor] .
 op unit-id :_ : Nat -> Attribute [ctor] .
 op msg-creation :_ : QidSet -> Attribute [ctor] .
 op msg-consumption :_ : QidSet -> Attribute [ctor] .
 op mode :_ : Mode -> Attribute [ctor] .

 *********************************************************************************
 *** Rule for setting the current mode to "process" for message-passing        ***
 *** semantics.                                                                ***
 *********************************************************************************
 rl [mode-process] :
    < O : MCPSDC | input : ('set`mode`process`..@MCPSCommand@), output : nil,
                   mode : M, AtS >
 => < O : MCPSDC | input : nilTermList, output : print-mode(process),
                   mode : process, AtS >  .

 *********************************************************************************
 *** Rule for setting the current mode to "trace" for message-passing          ***
 *** semantics.                                                                ***
 *********************************************************************************
 rl [mode-trace] :
    < O : MCPSDC | input : ('set`mode`trace`..@MCPSCommand@), output : nil,
                   mode : M, AtS >
 => < O : MCPSDC | input : nilTermList, output : print-mode(trace),
                   mode : trace, AtS >  .

 *********************************************************************************
 *** Parsing rule for the sorts standing for the memory.                       ***
 *** The list of tokens is introduced in the corresponding attribute.          ***                                                                 ***
 *********************************************************************************
 crl [memory-sorts] :
     < O : MCPSDC | input : ('memory`sorts_.['neTokenList[T]]), output : nil,
                    memory : QS, AtS >
  => < O : MCPSDC | input : nilTermList, output : print-memory-sorts(QIL),
                    memory : QS', AtS >
  if QIL := downQidList(T) /\
     QS' := list2set(QIL) .

 *********************************************************************************
 *** Parsing rule for the operators creating messages.                         ***
 *** The list of tokens is introduced in the corresponding attribute.          ***                                                                 ***
 *********************************************************************************
 crl [msg-creation-ops] :
     < O : MCPSDC | input : ('msg`creation_.['neTokenList[T]]), output : nil,
                    msg-creation : QS, AtS >
  => < O : MCPSDC | input : nilTermList, output : print-msg-creation(QIL),
                    msg-creation : QS', AtS >
  if QIL := downQidList(T) /\
     QS' := list2set(QIL) .

 *********************************************************************************
 *** Parsing rule for the operators consuming messages.                        ***
 *** The list of tokens is introduced in the corresponding attribute.          ***                                                                 ***
 *********************************************************************************
 crl [msg-creation-ops] :
     < O : MCPSDC | input : ('msg`consumption_.['neTokenList[T]]), output : nil,
                    msg-consumption : QS, AtS >
  => < O : MCPSDC | input : nilTermList, output : print-msg-consumption(QIL),
                    msg-consumption : QS', AtS >
  if QIL := downQidList(T) /\
     QS' := list2set(QIL) .

 *********************************************************************************
 *** Parsing rule for the operator standing for the unit.                      ***
 *** It does not indicate the argument identifying the unit, so it can only    ***
 *** fail if it cannot be parsed as a Qid.                                     ***
 *********************************************************************************
 crl [unit-sort] :
     < O : MCPSDC | input : ('unit_.['token[T]]), output : nil, unit : Q, AtS >
  => < O : MCPSDC | input : nilTermList, output : print-unit-sort(Q'), unit : Q', AtS >
  if Q' := downQid(T) .

 crl [unit-sort-error] :
     < O : MCPSDC | input : ('unit_.['token[T]]), output : nil, AtS >
  => < O : MCPSDC | input : nilTermList, output : comm-error-msg, AtS >
  if not (downQid(T) :: Qid) .

 *********************************************************************************
 *** Parsing rule for the operator standing for the unit.                      ***
 *** It indicates the argument identifying the unit, so it can fail if it      ***
 *** the first argument cannot be parsed as a Qid or the second one does not   ***
 *** stand for a natural number.                                               ***
 *********************************************************************************
 crl [unit-sort-id] :
     < O : MCPSDC | input : ('unit_id_.['token[T], 'token[T']]), output : nil,
                    unit : Q, unit-id : N, AtS >
  => < O : MCPSDC | input : nilTermList, output : print-unit-sort-id(Q', Q''),
                    unit : Q', unit-id : N', AtS >
  if Q' := downQid(T) /\
     Q'' := downQid(T') /\
     S := string(Q'') /\
     N' := rat(S, 10) .

 crl [unit-sort-id-error-sort] :
     < O : MCPSDC | input : ('unit_id_.['token[T], 'token[T']]), output : nil, AtS >
  => < O : MCPSDC | input : nilTermList, output : comm-error-msg, AtS >
  if not (downQid(T) :: Qid) .

 crl [unit-sort-id-error-arg1] :
     < O : MCPSDC | input : ('unit_id_.['token[T], 'token[T']]), output : nil, AtS >
  => < O : MCPSDC | input : nilTermList, output : comm-error-msg, AtS >
  if not (downQid(T') :: Qid) .

 crl [unit-sort-id-error-arg2] :
     < O : MCPSDC | input : ('unit_id_.['token[T], 'token[T']]), output : nil, AtS >
  => < O : MCPSDC | input : nilTermList, output : comm-error-msg, AtS >
  if S := string(downQid(T')) /\
     not (rat(S, 10) :: Nat) .

 *********************************************************************************
 *** Parsing rule for the transformation for shared memory.                    ***
 *** It prints the results given by the function above.                        ***
 *********************************************************************************
 crl [shared-memory-analysis] :
     < O : MCPSDC | db : DB, input : ('shared`memory`analysis_.['bubble[T]]), output : nil,
                    default : ME, memory : QS, unit : Q', unit-id : N, AtS >
  => < O : MCPSDC | db : DB, input : nilTermList, output : QIL, default : ME, memory : QS,
                    unit : Q', unit-id : N, AtS >
  if [B, QIL] := processSMA(T, ME, QS, Q', N, DB) .

 *********************************************************************************
 *** Parsing rule for the transformation for shared memory.                    ***
 *** It prints the results given by the function above.                        ***
 *********************************************************************************
 crl [shared-memory-analysis] :
     < O : MCPSDC | db : DB, input : ('msg`passing`analysis_.['bubble[T]]), output : nil,
                    default : ME, msg-creation : QS, msg-consumption : QS', unit : Q',
                    unit-id : N, mode : M, AtS >
  => < O : MCPSDC | db : DB, input : nilTermList, output : QIL, default : ME,
                    msg-creation : QS, msg-consumption : QS', unit : Q', unit-id : N,
                    mode : M, AtS >
  if [B, QIL] := processMPA(T, ME, QS, QS', Q', N, M, DB) .

  ****************************************************************************************
  ***                              Auxiliary functions                                 ***
  ****************************************************************************************
  op list2set : QidList -> QidSet .
  eq list2set(nil) = none .
  eq list2set(Q QIL) = Q ; list2set(QIL) .
endm

mod MCPS-INIT is
 inc LOOP-MODE .
 pr MCPS .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-mcps : -> System .

 op init-state : -> AttributeSet .
 eq init-state = db : initialDatabase, default : 'CONVERSION, memory : none,
                 unit : 'Bool, unit-id : 0, msg-creation : none, msg-consumption : none,
                 mode : process .

 rl [init] :
    init-mcps
 => [nil, < o : MCPSDatabase | input : nilTermList, output : nil, init-state >, mcps-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(MCPS-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(MCPS-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(MCPS-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(MCPS-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(MCPS-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

*** for debugging purposes
set print attribute on .

loop init-mcps .

